#!/usr/bin/env node

// Native
import fs from 'fs'
import path from 'path'

// Packages
import {parse} from 'url'
import {StringDecoder} from 'string_decoder'
import micro, {send} from 'micro'
import {red, green} from 'chalk'
import args from 'args'
import {compile} from 'handlebars'
import {isBinary} from 'istextorbinary'
import filesize from 'filesize'
import mime from 'mime'
import toPromise from 'denodeify'
import compress from 'micro-compress'

args
  .option('port', 'Port to listen on', 3000)
  .option('cache', 'How long static files should be cached in the browser (seconds)', 3600)
  .option('single', 'Serve single page apps with only one index.html')
  .option('unzipped', 'Disable GZIP compression')

const flags = args.parse(process.argv)
const directory = args.sub[0]

process.env.ASSET_DIR = '/' + Math.random().toString(36).substr(2, 10)

let current = process.cwd()

if (directory) {
  current = path.resolve(process.cwd(), directory)
}

const isDir = async dir => {
  let stats

  try {
    stats = await toPromise(fs.stat)(dir)
  } catch (err) {
    return false
  }

  if (stats.isDirectory()) {
    return true
  }

  return false
}

const exists = async file => {
  try {
    await toPromise(fs.stat)(file)
  } catch (err) {
    return false
  }

  return true
}

const prepareView = () => {
  let viewContent = false
  const viewPath = path.normalize(path.join(__dirname, '/../../views/index.hbs'))

  try {
    viewContent = fs.readFileSync(viewPath, 'utf8')
  } catch (err) {
    throw err
  }

  return compile(viewContent)
}

const ignoredFiles = [
  '.DS_Store',
  '.git/'
]

const renderDirectory = async dir => {
  let files = []
  const subPath = path.relative(current, dir)

  if (!await exists(dir)) {
    return false
  }

  try {
    files = await toPromise(fs.readdir)(dir)
  } catch (err) {
    throw err
  }

  for (const file of files) {
    const filePath = path.resolve(dir, file)
    const index = files.indexOf(file)
    const details = path.parse(filePath)

    details.ext = details.ext.split('.')[1]
    details.relative = path.join(subPath, details.base)

    if (await isDir(filePath)) {
      details.base += '/'
    } else {
      let fileStats

      try {
        fileStats = await toPromise(fs.stat)(filePath)
      } catch (err) {
        throw err
      }

      details.size = filesize(fileStats.size, {round: 0})
    }

    if (ignoredFiles.indexOf(details.base) > -1) {
      delete files[index]
    } else {
      files[files.indexOf(file)] = details
    }
  }

  if (dir.indexOf(current + '/') > -1) {
    files.unshift({
      base: '..',
      relative: '..'
    })
  }

  const render = prepareView()
  const directory = path.join(path.basename(current), subPath, '/')
  const pathParts = directory.split('/')

  const paths = []
  pathParts.pop()

  for (const part in pathParts) {
    if (!{}.hasOwnProperty.call(pathParts, part)) {
      continue
    }

    let before = 0
    const parents = []

    while (before <= part) {
      parents.push(pathParts[before])
      before++
    }

    parents.shift()

    paths.push({
      name: pathParts[part],
      url: '/' + parents.join('/')
    })
  }

  const details = {
    port: flags.port,
    files,
    assetDir: process.env.ASSET_DIR,
    directory,
    nodeVersion: process.version.split('v')[1],
    paths
  }

  return render(details)
}

const handler = async (req, res) => {
  const {pathname} = parse(req.url)
  let related = path.parse(path.join(current, pathname))

  if (related.dir.indexOf(process.env.ASSET_DIR) > -1) {
    const relative = path.relative(process.env.ASSET_DIR, pathname)
    related = path.parse(path.join(__dirname, '/../assets', relative))
  }

  related = decodeURIComponent(path.format(related))

  if (!await exists(related) && flags.single === undefined) {
    return send(res, 404, 'Not found')
  }

  // Check if file or directory path
  if (path.parse(related).ext === '') {
    let indexPath = path.join(related, '/index.html')

    if (!await isDir(related) && flags.single === undefined) {
      return send(res, 404, 'Not found')
    }

    res.setHeader('Content-Type', mime.lookup(indexPath) + '; charset=utf-8')

    if (!await exists(indexPath)) {
      // Try to render the current directory's content
      const renderedDir = await renderDirectory(related)

      // If it works, send the directory listing to the user
      if (renderedDir) {
        return send(res, 200, renderedDir)
      }

      // And if it doesn't, see if it's a single page application
      // If that's not true either, send an error
      if (!flags.single) {
        return send(res, 404, 'Not found')
      }

      // But IF IT IS true, load the SPA's root index file
      indexPath = path.join(current, '/index.html')
    }

    let indexContent

    try {
      indexContent = await toPromise(fs.readFile)(indexPath, 'utf8')
    } catch (err) {
      throw err
    }

    return send(res, 200, indexContent)
  }

  let body = 'Not able to load file!'
  let stats
  let binaryStat

  try {
    body = await toPromise(fs.readFile)(related)
    stats = await toPromise(fs.stat)(related)
    binaryStat = await toPromise(isBinary)(path.parse(related).base, body)
  } catch (err) {
    throw err
  }

  const getETag = s => '"' + s.dev + '-' + s.ino + '-' + s.mtime.getTime() + '"'

  let requestDate = req.headers['if-modified-since']
  let statusCode = 200

  if (requestDate) {
    requestDate = new Date(requestDate)

    if (requestDate.getTime() === stats.mtime.getTime()) {
      statusCode = 304
    }
  }

  const defaultHeaders = {
    'Cache-Control': 'public, max-age=' + flags.cache,
    'Pragma': 'public',
    'ETag': getETag(stats)
  }

  for (const header in defaultHeaders) {
    if (!{}.hasOwnProperty.call(defaultHeaders, header)) {
      continue
    }

    res.setHeader(header, defaultHeaders[header])
  }

  if (binaryStat) {
    res.statusCode = statusCode
    res.end(body, 'binary')
  } else {
    const decoder = new StringDecoder('utf8')
    let contentType = mime.lookup(related)

    if (!path.parse(related).ext) {
      contentType = 'text/plain'
    }

    res.setHeader('Content-Type', contentType + '; charset=utf-8')
    send(res, statusCode, decoder.write(body))
  }
}

const server = flags.unzipped ? micro(handler) : micro(compress(handler))

server.listen(flags.port, async () => {
  const details = server.address()

  process.on('SIGINT', () => {
    server.close()
    process.exit(0)
  })

  if (!await isDir(current)) {
    console.error(red('Specified directory doesn\'t exist!'))
    process.exit(1)
  }

  if (!process.env.NOW) {
    console.log(green(`Running on http://localhost:${details.port}`))
  }
})
